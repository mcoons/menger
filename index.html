<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Menger Sponge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="babylon.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>

    <div class="textcontainer">
        <h1>Menger Sponge m4</h1>
        <ol>
            <li><h3>Begin with a cube.</h3></li>
            <li><h3>Divide every face of the cube into 9 squares, like a Rubik's Cube. This will sub-divide the cube into 27 smaller cubes.</h3></li>
            <li><h3>Remove the smaller cube in the middle of each face, and remove the smaller cube in the very center of the larger cube, leaving 20 smaller cubes. This is a level-1 Menger sponge (resembling a Void Cube).</h3></li>
            <li><h3>Repeat steps 2 and 3 for each of the remaining smaller cubes, and continue to iterate ad infinitum.</h3></li>
        </ol>      
        <h2>Click on the image then use the arrows and left mouse hold to explore the cubes.</h2>          
        <div id = "calculating"><h1>Calculating Sponges</h1><img src="./loading.gif"></img></div>
        <div id="webgl"></div>
    </div>

<!-- 5,760,000  indices - 3,840,000 vertices, in 1 mesh -->
<!-- 2,483,040  indices - 1,492,120 vertices, in 20 meshes -->   
<!-- 1,476      indices - 984 vertices, in 246  meshes -->

    <canvas id="renderCanvas"></canvas>

    <script src="./sponge.js">
    

        // var maxInterval = 1;  
        // const remove = [4, 10, 12, 13, 14, 16, 22];
        // const scales = [243, 81, 27, 9, 3 ,1, 1/3];
        // const cloneScales = [1, 1/3, 1/9, 1/27, 1/81, 1/243];
        // var meshes = [];

        // window.addEventListener('DOMContentLoaded', function(){

        //     var canvas = document.getElementById('renderCanvas');
        //     var engine = new BABYLON.Engine(canvas, true);
        //     var scene = createScene(engine, canvas);

        //     createSponge(scene);
        //     document.getElementById("calculating").style.display = "none"

        //     // scene.getMeshByName('box0').dispose();
        //     // scene.getMeshByName('box1').dispose();
        //     // scene.getMeshByName('box2').dispose();
        //     // scene.getMeshByName('box3').dispose();

        //     engine.runRenderLoop(function(){ 
        //         scene.render(); 
        //         // console.log("indices:", scene.getActiveIndices())
        //         // console.log("meshes:", scene.getActiveMeshes())
        //     });

        //     window.addEventListener('resize', function(){ 
        //         engine.resize(); 
        //     });
        // });


        // function createScene(engine, canvas){

        //     var scene = new BABYLON.Scene(engine);

        //     var camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 345, -1250), scene);
        //     camera.setTarget(new BABYLON.Vector3(0,0,0));
        //     camera.attachControl(canvas, false);

        //     var hlight = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0,1,1), scene);
        //     hlight.intensity = .3;

        //     var plight1 = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(-600, 50, 0), scene);
        //     var plight2 = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(0, -600, 0), scene);
        //     var plight3 = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(0, 250, -600), scene);
        //     plight1.diffuse = new BABYLON.Color3(1, .2, .2);
        //     plight2.diffuse = new BABYLON.Color3(.2, 1, .2);
        //     plight3.diffuse = new BABYLON.Color3(.2, .2, 1);

        //     return scene;
        // }

        // // create multiple menger sponges
        // function createSponge(scene, mat){

        //     // create an initial block to prime the template
        //     let template = BABYLON.MeshBuilder.CreateBox("box", {height: 243, width: 243, depth: 243}, scene);

        //     // create a template and 4 menger sponges
        //     // use the previous mesh sponge as a template block for the next sponge
        //     for (let j = 0; j <= 4; j++){

        //         calculateCenters(new BABYLON.Vector3(0,0,0), 1, template);

        //         template = BABYLON.Mesh.MergeMeshes(meshes, true, true);
        //         template.position = new BABYLON.Vector3(-500+(250*j),0,0);
        //         template.name = "box"+j;

        //         meshes = [];

        //         // increase the max interval after the initial template creation
        //         if (maxInterval === 1) 
        //             maxInterval = 2;
        //     }
        //     // dispose of the initial box template
        //     scene.getMeshByName('box').dispose();
        // }

        // // Recursively calculate 27 centers of surrounding blocks
        // function calculateCenters(center, interval, template){

        //     // If complexity is reached then render the template and return
        //     if (interval === maxInterval){

        //         let box = template.clone("clone");    

        //         box.scaling = new BABYLON.Vector3(cloneScales[interval-1],cloneScales[interval-1],cloneScales[interval-1]);
        //         box.position = center;

        //         meshes.push(box);

        //         return;
        //     }

        //     // Get the scale for this intervals centers delta
        //     let s3 = scales[interval];

        //     // Count is the 'location'of the block to determine the removal
        //     let count = 0;

        //     // Calculate the new block centers ignoring the central removed blocks
        //     for (let y = center.y-s3; y <= center.y+s3; y+=s3)
        //     for (let z = center.z-s3; z <= center.z+s3; z+=s3)
        //     for (let x = center.x-s3; x <= center.x+s3; x+=s3){
        //         if (!remove.includes(count)) 
        //             calculateCenters(new BABYLON.Vector3(x,y,z), interval+1, template);
        //         count++;
        //     }
        // }

</script>
</body>
</html>